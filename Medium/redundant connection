"""
test cases:
[[3,4],[1,2],[2,4],[3,5],[2,5]]

OLE
[[5,115],[155,198],[50,121],[11,154],[8,110],[86,181],[2,151],[45,163],[18,185],[152,160],[7,23],[59,123],[122,183],[138,157],[40,62],[74,193],[127,142],[93,100],[33,152],[15,109],[88,188],[1,180],[39,111],[89,180],[105,173],[47,112],[39,125],[123,198],[17,99],[116,147],[100,106],[32,60],[151,192],[10,94],[105,122],[26,53],[89,121],[36,138],[97,185],[11,76],[29,189],[72,187],[137,143],[77,118],[40,177],[138,178],[76,151],[114,171],[86,155],[8,173],[50,87],[24,109],[162,170],[46,112],[5,187],[12,37],[20,49],[27,29],[121,141],[146,191],[57,76],[84,126],[54,74],[82,189],[131,190],[38,76],[15,186],[74,182],[79,175],[97,156],[102,136],[52,141],[15,86],[25,99],[85,115],[101,132],[66,106],[57,159],[80,114],[28,79],[106,194],[122,196],[60,73],[109,177],[153,162],[21,103],[73,120],[104,145],[97,173],[62,130],[59,161],[6,23],[94,133],[117,150],[44,197],[75,88],[14,83],[99,162],[32,200],[53,105],[144,188],[4,151],[42,134],[14,156],[29,41],[102,199],[106,183],[162,184],[48,79],[98,162],[9,58],[107,125],[19,173],[42,136],[67,126],[79,96],[123,137],[27,132],[81,93],[41,164],[58,176],[117,129],[16,93],[21,94],[1,167],[13,131],[110,138],[90,151],[125,191],[5,92],[22,195],[147,164],[16,108],[31,111],[80,104],[84,163],[70,178],[71,135],[12,56],[30,162],[47,174],[68,139],[9,134],[35,99],[150,164],[26,108],[80,125],[32,132],[142,189],[65,125],[69,119],[44,119],[23,156],[61,197],[55,111],[85,124],[115,143],[74,200],[114,135],[86,140],[68,162],[141,159],[134,166],[43,143],[72,158],[77,120],[7,117],[119,167],[161,163],[103,152],[10,61],[34,126],[56,88],[17,172],[44,78],[46,168],[37,105],[67,73],[32,179],[46,149],[190,192],[49,135],[49,149],[131,165],[95,138],[2,22],[73,91],[3,172],[67,113],[11,64],[61,66],[128,144],[26,169],[70,96],[17,85],[40,51],[117,199],[63,199],[13,149],[49,148]]


"""

class Solution:
    def findRedundantConnection(self, edges):
        """
        :type edges: List[List[int]]
        :rtype: List[int]
        """
        indexes = dict()
        unions = dict()
        res = []
        # initialize group index for each node
        for ed in edges:
            indexes[ed[0]] = ed[0]
            indexes[ed[1]] = ed[1]
            unions[ed[0]] = [ed[0]]
            unions[ed[1]] = [ed[1]]

        # unify: find grouping index for each node, if the two nodes on one edge has the same index, it's a circle
        for ed in edges:
            if indexes[ed[0]] == indexes[ed[1]]: # has been assigned before (circle in the graph)
                res.append(ed)
            else:
                min_id = min(indexes[ed[0]], indexes[ed[1]])
                max_id = max(indexes[ed[0]], indexes[ed[1]])
                #unify two groups:
                unions[min_id] += unions[max_id]
                unions[min_id] = list(set(unions[min_id]))
                for tmp_node in unions[max_id]:
                    indexes[tmp_node] = min_id
                unions.pop(max_id)
            # print(unions)
        return res[-1]
