class Solution:
    def findMaxForm(self, strs, m, n):
        """
        TIME: O(MNL)
        SPACE: O(MN)
        only work with python2, TLE with python3
        :type strs: List[str]
        :type m: int
        :type n: int
        :rtype: int
        """
        """
        logistic: DP problem
        dp[k, x, y] = max(dp[k-1, x-mm, y - nn], dp[k-1, x, y])
        k: idx of str from 0 to k
        x, y: # of zeros and ones
        mm, nn: # of zeros, ones in str[k]
        max(1st, 2nd): max(choose str[k], not choose str[k])
        """
        def helper(s):
            return s.count('0'), s.count('1')
        dp = [[[0] * (n+1) for y in range(m+1)] for z in range(len(strs) + 1)]

        for idx in range(1, len(strs)+1):
            c0, c1 = helper(strs[idx-1])
            for xi in range(m+1):
                for yi in range(n+1):
                    if xi >= c0 and yi >= c1:
                        dp[idx][xi][yi] = max(dp[idx-1][xi][yi], 1 + dp[idx-1][xi-c0][yi-c1])
                    else:
                        dp[idx][xi][yi] = dp[idx-1][xi][yi]

        return dp[len(strs)][m][n]


class Solution2:
    def findMaxForm(self, strs, m, n):
        """
        TIME: O(MNL)
        SPACE: O(MN)
        only work with python2, TLE with python3
        :type strs: List[str]
        :type m: int
        :type n: int
        :rtype: int
        """
        """
        logistic: DP problem
        dp[k, x, y] = max(dp[k-1, x-mm, y - nn], dp[k-1, x, y])
        k: idx of str from 0 to k
        x, y: # of zeros and ones
        mm, nn: # of zeros, ones in str[k]
        max(1st, 2nd): max(choose str[k], not choose str[k])
        """
        def helper(s):
            return s.count('0'), s.count('1')

        curr, prev = [[0] * (n+1) for _ in range(m+1)],  [[0] * (n+1) for _ in range(m+1)]
        for idx, s in enumerate(strs):
            c0, c1 = helper(s)
            for xi in range(m+1):
                for yi in range(n+1):
                    if c0 <= xi and c1 <= yi:
                        curr[xi][yi] = max(prev[xi][yi], prev[xi - c0][yi - c1] + 1)
                    else:
                        curr[xi][yi] = prev[xi][yi]
            prev, curr = curr, prev
        return prev[m][n]


# class Solution:
# 	def findMaxForm(self, strs, m, n):
# 		"""
#         :type strs: List[str]
#         :type m: int
#         :type n: int
#         :rtype: int
#         """
# 		"""
#         logistic: DP problem
#         dp[k, x, y] = max(dp[k-1, x-mm, y - nn], dp[k-1, x, y])
#         k: idx of str from 0 to k
#         x, y: # of zeros and ones
#         mm, nn: # of zeros, ones in str[k]
#         max(1st, 2nd): max(choose str[k], not choose str[k])
#         """
#
# 		def helper(s):
# 			return s.count('0'), s.count('1')
#
# 		dp = dict()
# 		if len(strs) < 1:
# 			return 0
# 		c0, c1 = helper(strs[0])
# 		for xi in range(0, m + 1):
# 			for yi in range(0, n + 1):
# 				dp[(0, xi, yi)] = 1 if (c0 <= xi and c1 <= yi) else 0
# 		for idx, s in enumerate(strs[1:]):
# 			c0, c1 = helper(s)
# 			for xi in range(0, m + 1):
# 				for yi in range(0, n + 1):
# 					dp[(idx + 1, xi, yi)] = max(dp[(idx, xi, yi)], 1 + dp[(idx, xi - c0, yi - c1)]) if (
# 							c0 <= xi and c1 <= yi) else dp[(idx, xi, yi)]
# 		#        [print(d, dp[d]) for d in dp]
# 		return dp[(len(strs) - 1, m, n)]


strs = ["11","01","11","01","11","01","11","01","11","01","11","01",
        "11","01","11","01","11","01","11","01","11","01","11","01",
        "11","01","11","01","11","01","11","01","11","01","11","01",
        "11","01","11","01","11","01","11","01","11","01","11","01",
        "11","01","11","01","11","01","11","01","11","01","11","01",
        "11","01","11","01","11","01","11","01","11","01","11","01","11",
        "01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01",
        "11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11",
        "01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01",
        "11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11",
        "01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01",
        "11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11",
        "01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01",
        "11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11",
        "01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01",
        "11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11",
        "01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11",
        "01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11",
        "01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11",
        "01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11",
        "01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01",
        "11","01","11","01","11","01","11","01","11","01","11","01",
        "11","01","11","01","11","01","11","01","11","01","11","01","11","01",
        "11","01","11","01","11","01","11","01","11","01","11","01","11","01",
        "11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11",
        "01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11",
        "01","11","01","11","01","11","01","11","01","11","01","11","01","11","01","11","01"]
m = 50
n = 50
# strs = ["10","0001","111001","1","0"]
# m = 5
# 3
a = Solution()
import time

t1 = time.time()
for i in range(10):
    a.findMaxForm(strs, m, n)
t2 = time.time()
print(t2 - t1)
